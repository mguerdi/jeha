diff --git a/src/HOL/Tools/Jeha/clause_id.ML b/src/HOL/Tools/Jeha/clause_id.ML
--- a/src/HOL/Tools/Jeha/clause_id.ML
+++ b/src/HOL/Tools/Jeha/clause_id.ML
@@ -10,7 +10,7 @@
 (* FIXME: why do we need this? Doesn't the prover run in a single thread? If not, how can we get one
 id generator per prover instance? *)
 local
-  val lock = Mutex.mutex ();
+  val lock = Thread.Mutex.mutex ();
 in
   fun critical e () = Multithreading.synchronized "jeha" lock e
 end;
diff --git a/src/HOL/Tools/Jeha/jclause.ML b/src/HOL/Tools/Jeha/jclause.ML
--- a/src/HOL/Tools/Jeha/jclause.ML
+++ b/src/HOL/Tools/Jeha/jclause.ML
@@ -208,7 +208,7 @@
 
 fun incr_indexes increment clause =
   clause
-  |> map_literals (map (JLit.map (Logic.incr_indexes ([], [], increment))))
+  |> map_literals (map (JLit.map (Logic.incr_indexes ([], increment))))
   |> map_maxidx (K (increment + maxidx clause))
 
 val kbo = Jeha_Order.mk_multiset_order_of_strict JLit.kbo o apply2 literals
diff --git a/src/HOL/Tools/Jeha/jeha.ML b/src/HOL/Tools/Jeha/jeha.ML
--- a/src/HOL/Tools/Jeha/jeha.ML
+++ b/src/HOL/Tools/Jeha/jeha.ML
@@ -353,7 +353,7 @@
   let
     val unit_shift = target_maxidx + 1
     val unit_lit =
-      unit_lit |> JLit.map (Logic.incr_indexes ([], [], unit_shift))
+      unit_lit |> JLit.map (Logic.incr_indexes ([], unit_shift))
     val maxidx = unit_maxidx + target_maxidx + 1
     val (lhs, rhs, true) = unit_lit (* Schulz: s, t *)
     val (target_lhs, target_rhs, _) = target_lit (* Schulz: u[], u[]*)
