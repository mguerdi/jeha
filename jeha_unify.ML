(* Wrapper around Isabelles unfication functions, needed because of the following remark in unify.ML:
"The outermost functions assume the terms to be unified already have the same type." *)

(* FIXME: Can schematic variables only have schematic types? What issues does this cause? *)

signature JEHA_UNIFY =
sig
  (* from unify.ML *)
  val smash_unifiers: Context.generic -> (term * term) list -> Envir.env -> Envir.env Seq.seq
  (* from more_unify.ML *)
  val matchers: Context.generic -> int -> (term * term) list -> Envir.env Seq.seq
  (* unification and matching of (symmetric!) equality literals *)
  val literal_smash_unifiers : Context.generic -> (JLit.T * JLit.T) -> Envir.env -> Envir.env Seq.seq
  val literal_matchers : Context.generic -> int -> (JLit.T * JLit.T) -> Envir.env Seq.seq
end

structure Jeha_Unify : JEHA_UNIFY =
struct

fun give_to_undefined t =
  let
    val T = fastype_of t
  in
    (* FIXME: there is a function with this type, maybe better than undefined *)
    Const (@{const_name undefined}, T --> @{typ unit}) $ t
  end

fun smash_unifiers ctxt tus env =
  let
    val maxidx =
      fold
        (fn tu => fn maxidx => Int.max (maxidx, Int.max (apply2 maxidx_of_term tu)))
        tus
        ~1
    val env = Envir.merge (Envir.empty maxidx, env)
    val tus = map (apply2 give_to_undefined) tus
  in
    Unify.smash_unifiers ctxt tus env
  end

fun matchers ctxt maxidx pairs =
  let
    (* ensures that fresh variables generated by Unify.smash_unifiers (called by
    Unify.matchers below) are greater than maxidx *)
    val v = Var (("maxidxforcer", maxidx), @{typ "unit"})
  in
    Unify.matchers ctxt (map (apply2 give_to_undefined) ((v, v) :: pairs))
  end

fun literal_smash_unifiers ctxt ((s, t, b), (s', t', b')) env =
  if not (b = b') then Seq.empty else
  Seq.interleave
    ( smash_unifiers ctxt [(s, s'), (t, t')] env
    , smash_unifiers ctxt [(s, t'), (t, s')] env )

fun literal_matchers ctxt maxidx ((s, t, b), (s', t', b')) =
  if not (b = b') then Seq.empty else
  Seq.interleave
    ( matchers ctxt maxidx [(s, s'), (t, t')]
    , matchers ctxt maxidx [(s, t'), (t, s')] )

end
